This chronicals my new research OS, Saturn, named after the Saturn V.

"We choose to do [this], not because [it] is easy, but because [it] is hard; because that goal will serve to organize and measure the best of our energies and skills..."

My initial goal is to boot into a self hosting environment, where I can
work on the kernel in a live environment.

* Step 1: The Cross Compiler
compiling with clang:

clang -c filename.c -o filename.o --target=i686-pc-none-elf -march=i686
    -ffreestanding -fno-exceptions -fno-rtti -Wall -Wextra

boot asm:

i686-elf-as boot.s -o boot.o

linking the kernel:

clang -T src/linker.ld -o saturn.bin -ffreestanding -nostdlib boot.o kernel.o
    --target=i686-pc-none-elf -march=i686

* Step 2: Basic printing to screen

note: capturing lambdas are supported


implemented basic printf with %c, %s, %d, %x, %o supported

* Step 3: IDT

note: objdump is really helpful

cpuid_vendor values:
eax: 4, ebx: 0x756e6547, ecx: 6c65746e, edx: 49656e69

* GDB:

x/20d address
s
n
si
info registers
x/i $pc

* Step 4: Paging

got basic paging to work. so far:
create PageDirectory, PageTables. Identity map from 0 to kernelENd
Can allocate a page after paging enabled and then access it

next steps:
** DONE - remove/refactor kernel page table hardcoding
** DONE _ physical page allocation should happen in page fault handler
remove the actual individual *Page* allocations, but keep the allocations
for page tables and directories
** DONE - page fault handler
*** detect if its an invalid memory access, or an unallocated one
*** allocate physical pages on demand
** switch to higher half kernel
