This chronicals my new research OS, Saturn, named after the Saturn V.

"We choose to do [this], not because [it] is easy, but because [it] is hard; because that goal will serve to organize and measure the best of our energies and skills..."

My initial goal is to boot into a self hosting environment, where I can
work on the kernel in a live environment.

* Step 1: The Cross Compiler
compiling with clang:

clang -c filename.c -o filename.o --target=i686-pc-none-elf -march=i686
    -ffreestanding -fno-exceptions -fno-rtti -Wall -Wextra

boot asm:

i686-elf-as boot.s -o boot.o

linking the kernel:

clang -T src/linker.ld -o saturn.bin -ffreestanding -nostdlib boot.o kernel.o
    --target=i686-pc-none-elf -march=i686

* Step 2: Basic printing to screen

note: capturing lambdas are supported


implemented basic printf with %c, %s, %d, %x, %o supported

* Step 3: IDT

note: objdump is really helpful

cpuid_vendor values:
eax: 4, ebx: 0x756e6547, ecx: 6c65746e, edx: 49656e69

* GDB:

x/20d address
s
n
si
info registers
x/i $pc
fin

* Step 4: Paging

got basic paging to work. so far:
create PageDirectory, PageTables. Identity map from 0 to kernelENd
Can allocate a page after paging enabled and then access it

next steps:
** DONE - remove/refactor kernel page table hardcoding
** DONE _ physical page allocation should happen in page fault handler
remove the actual individual *Page* allocations, but keep the allocations
for page tables and directories
** DONE - page fault handler
*** detect if its an invalid memory access, or an unallocated one
*** allocate physical pages on demand
** switch to higher half kernel

* Step 5: APIC & Interrupts

Note: PMM must be able to mark specific addresses as used

* Step 6: Multitasking

Very interesting note from f.osdev.org/viewtopic.php?f=15&t=30555

"This was exactly my line of thinking. If the driver identifies itself as belonging to a class (say "keyboard", to keep with the discussion), only grant it permissions for keyboard access. If it attempts to access services that it is not granted permissions to, the OS could either deny those requests or unload the driver entirely, depending on how critical the operation it performs is.

Of course, this doesn't prevent some odd behavior, such as a driver that simply transmutes the data (i.e. when an "A" is pressed, forward a "Q" to the kernel). In practice though, there is no reasonable precaution to be taken against that.

This also allows for the kernel to have some interesting/novel features to aid the programmer, as Brendan alluded to awhile back - the kernel could be instructed to log all driver I/O activity, for example, which would greatly aid in debugging new or experimental drivers."


-----------------

System calls: 0xFF (Final Fantasy)
0xFF, EAX=7, 9, A

** Next Steps
- [X] extract the TSS stuff and put it in its proper place
- [X] pass address to ring3 function instead of hardcoding taskA's
- [X] implement thread state
- [X] implement switch_to(thread)
- [X] implement find_thread_to_switch_to()
- [X] implement block_thread(reason)
- [X] implement unblock_thread(reason)

* Intermission
- [X] malloc
- [X] libc++
  - [X] new

* Step 7: Usermode VGA Driver
- [X] IPC
** IPC Design
   -each task will have a dedicated block of memory for storing messages, allocated after the kernel stack
   -asynchronous send, unless target's mailbox is full then blocks
   
   possible to have a shared mailbox? for tasks A and B that want to communicate without interrupts,
   task A allocates a mailbox and sends the address to b, b maps that as readonly,
   b then creates its own

- [X] Driver framework, driver identification (eg load as VGA_DRIVER grants 0xb000 user-mode memory mapped to the driver)
  
* Step 8: Usermode Terminal Emulator
- [ ] handle common ansi escape sequences (colour, moving the cursor)

* Step 9: Usermode Keyboard Driver

aside: use scheme as the shell scripting language
