#pragma once

#include <stddef.h>

namespace std {

    template<typename T>
    struct allocator;

    template<typename T, class Allocator = std::allocator<T>>
    class vector {
    public:

        //types:
        using size_type = size_t;
        using value_type = T;
        using reference = value_type&;
        using const_reference = const value_type&;
        //TODO: this should be RandomAccessIterator, but iterators don't exist yet
        using iterator = value_type*;
        
        //construct/copy/destroy
        vector() {
            maxItems = 10;
            data = new T[maxItems];
        }

        //iterators:
        iterator begin() noexcept {
            return data;
        }

        iterator end() noexcept {
            return data + items;
        }

        //capacity
        [[nodiscard]]
        bool empty() const noexcept {
            return items == 0;
        }

        size_type size() const noexcept {
            return items;
        }

        //element access:
        reference operator[](size_type pos) {
            return data[pos];
        }

        reference back() {
            return data[items - 1];
        }

        const_reference back() const {
            return data[items - 1];
        }

        //modifiers
        void push_back(const T& item) {
            if (items >= maxItems) {
                auto oldSize = maxItems;
                maxItems *= 2;
                auto newData = new T[maxItems];

                for(size_type i = 0; i < oldSize; i++) { 
                    newData[i] = data[i];
                }

                delete data;
                data = newData;
            }

            data[items] = item;
            items++;
        }

        void pop_back() {
            items--;
        } 

        iterator erase(iterator pos) {

            for (auto it = pos; it != end(); it++) {
                auto next = it + 1;

                if (next != end()) {
                    *it = *next;
                }
            }

            items--;



            return pos + 1;
        }

        void clear() noexcept {
            items = 0;
        }

    private:

        size_type items {0};
        size_type maxItems {0};
        T* data {nullptr};
    };
}