#pragma once

#include <stddef.h>

namespace std {

    template<typename T>
    struct allocator {};

    template<typename T, class Allocator = std::allocator<T>>
    class vector {
    public:

        typedef size_t size_type; 
        typedef T value_type;
        typedef value_type& reference;
        //TODO: this should be RandomAccessIterator, but iterators don't exist yet
        typedef value_type* iterator;
        
        vector() {
            maxItems = 10;
            data = new T[maxItems];
        }
        
        void push_back(const T& item) {
            if (items >= maxItems) {
                auto oldSize = maxItems;
                maxItems *= 2;
                auto newData = new T[maxItems];

                for(size_type i = 0; i < oldSize; i++) { 
                    newData[i] = data[i];
                }

                delete data;
                data = newData;
            }

            data[items] = item;
            items++;
        }

        iterator begin() noexcept {
            return data;
        }

        iterator end() noexcept {
            return data + items;
        }

        reference operator[](size_type pos) {
            return data[pos];
        }

        [[nodiscard]]
        bool empty() const noexcept {
            return items == 0;
        }

        size_type size() const noexcept {
            return items;
        }

        void clear() noexcept {
            items = 0;
        }

        iterator erase(iterator pos) {

            for (auto it = pos; it != end(); it++) {
                auto next = it + 1;

                if (next != end()) {
                    *it = *next;
                }
            }

            items--;



            return pos + 1;
        }

    private:

        size_type items {0};
        size_type maxItems {0};
        T* data {nullptr};
    };
}