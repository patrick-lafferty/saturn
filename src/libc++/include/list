#pragma once

#include <cstddef>

namespace std {

    template<typename T>
    struct Allocator {};

    template<class T, class Allocator = std::allocator<T>>
    class list {
    public:

        using value_type = T;
        using allocator_type = Allocator;
        using reference = value_type&;
        using const_reference = const value_type&;
        using size_type = size_t;

        //capacity
        bool empty() const noexcept {
            return count == 0;
        }

        size_type size() const noexcept {
            return count;
        }

        //element access
        reference front() {
            return head->value;
        }

        const_reference front() const {
            return head->value;
        }

        reference back() {
            return tail->value;
        }

        const_reference back() const {
            return tail->value;
        }
        
        //modifiers
        //emplace_front
        //emplace_back
        
        void push_front(const T& value) {
            if (head == nullptr) {
                head = new Node {nullptr, nullptr, value};
            }
            else {
                auto node = new Node{nullptr, head, value};
                head->previous = node;
                head = node;
            }

            count++;
        }

        //void push_front(T&&)

        void pop_front() {
            if (head != nullptr) {
                auto node = head->next;
                delete head;
                head = node;
                count--;
            }
        }

        void push_back(const T& value) {
            if (head == nullptr) {
                head = tail = new Node{nullptr, nullptr, value};
            }
            else {
                auto node = new Node{tail, nullptr, value};
                tail->next = node;
                tail = node;
            }

            count++;
        }

        //void push_back(T&&)

        void pop_back() {
            if (tail != nullptr) {
                auto node = tail->previous;
                delete tail;
                tail = node;
                count--;
            }
        }

    private:

        struct Node {
            Node* previous;
            Node* next;

            value_type value;
        };

        Node* head {nullptr};
        Node* tail {nullptr};
        uint32_t count {0};
    };
}