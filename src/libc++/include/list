#pragma once

#include <cstddef>
#include <iterator>

namespace std {

    template<typename T>
    struct Allocator {};

    template<class T, class Allocator = std::allocator<T>>
    class list {
    private:

        struct Node {
            Node* previous;
            Node* next;

            T value;
        };

        template<class ValueType>
        class ListIteratorBase {
        public:

            using difference_type = ptrdiff_t;
            using value_type = ValueType;
            using pointer = ValueType*;
            using reference = ValueType&;
            using iterator_category = forward_iterator_tag;

            ListIteratorBase() {
                value = nullptr;
            }

            ListIteratorBase(Node* node) {
                value = node;
            }

            bool operator==(const ListIteratorBase& other) const {
                return value == other.value;
            }

            bool operator!=(const ListIteratorBase& other) const {
                return !(value == other.value);
            }

            ListIteratorBase& operator++() {
                value = value->next;
                return *this;
            }

            reference operator*() const {
                return value->value;
            }

            pointer operator->() const {
                return &value->value;
            }

        protected:
            
            Node* value; 

            friend class list;
        };

        class ListIterator : public ListIteratorBase<T> {};
        class ConstListIterator : public ListIteratorBase<const T> {
        public:

            ConstListIterator(const ListIterator& other)
                : ListIteratorBase<const T>(other.value) {}

        };

    public:

        using value_type = T;
        using allocator_type = Allocator;
        using reference = value_type&;
        using const_reference = const value_type&;
        using size_type = size_t;
        //diference_type
        using iterator = ListIterator;
        using const_iterator = ConstListIterator;

        //iterators:
        iterator begin() noexcept {
            return iterator{head};
        }

        const_iterator begin() const noexcept {
            return const_iterator{head};
        }

        iterator end() noexcept {
            if (tail != nullptr) {
                return iterator{tail->next};
            }
            else {
                return iterator{nullptr};
            }
        }

        const_iterator end() const noexcept {
            if (tail != nullptr) {
                return const_iterator{tail->next};
            }
            else {
                return const_iterator{nullptr};
            }
        }

        //capacity
        bool empty() const noexcept {
            return count == 0;
        }

        size_type size() const noexcept {
            return count;
        }

        //element access
        reference front() {
            return head->value;
        }

        const_reference front() const {
            return head->value;
        }

        reference back() {
            return tail->value;
        }

        const_reference back() const {
            return tail->value;
        }
        
        //modifiers
        //emplace_front
        //emplace_back
        
        void push_front(const T& value) {
            if (head == nullptr) {
                head = new Node {nullptr, nullptr, value};
            }
            else {
                auto node = new Node{nullptr, head, value};
                head->previous = node;
                head = node;
            }

            count++;
        }

        //void push_front(T&&)

        void pop_front() {
            if (head != nullptr) {
                auto node = head->next;
                delete head;
                head = node;
                count--;
            }
        }

        void push_back(const T& value) {
            if (head == nullptr) {
                head = tail = new Node{nullptr, nullptr, value};
            }
            else {
                auto node = new Node{tail, nullptr, value};
                tail->next = node;
                tail = node;
            }

            count++;
        }

        //void push_back(T&&)

        void pop_back() {
            if (tail != nullptr) {
                auto node = tail->previous;
                delete tail;
                tail = node;
                count--;
            }
        }

        iterator erase(const_iterator position) {
            auto current = position.value;
            auto previous = current->previous;
            auto next = current->next;

            if (current == head) {
                head = next;
            }
            else if (current == tail) {
                tail = previous;
            }

            if (previous != nullptr) {
                previous->next = next;
            }

            if (next != nullptr) {
                next->previous = previous;
            }

            delete current;

            return iterator{next};
        }

    private:

        Node* head {nullptr};
        Node* tail {nullptr};
        uint32_t count {0};
    };
}